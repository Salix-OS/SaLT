#!/bin/sh
# vim: set syn=sh ai si et sw=2 st=2 ts=2 tw=0:
#
# This file is part of SaLT.
# Copyright: Cyrille Pontvieux <jrd@salixos.org>
# Licence: GPLv3+
# Version: 0.1.2
# Library for use by init and cleanup

if [ -f /etc/salt.cfg ]; then
  . /etc/salt.cfg
elif [ -f /mnt/salt/etc/salt.cfg ]; then
  . /mnt/salt/etc/salt.cfg
else
  echo "salt.cfg not found, cannot proceed further" >&2
  return 1
fi

# debug mode is done using kernel command line or by putting something in the file /SALT_DEBUG
SALT_DEBUG=$(cat /proc/cmdline 2>/dev/null | grep -q -w -i debug && echo 1 || cat /SALT_DEBUG /mnt/salt/SALT_DEBUG 2>/dev/null)
export SALT_DEBUG
SAVE_FILE_NAME=${ROOT_DIR}.save
export SAVE_FILE_NAME

COLOR_BLACK=30
COLOR_RED=31
COLOR_GREEN=32
COLOR_YELLOW=33
COLOR_BLUE=34
COLOR_MAGENTA=35
COLOR_CYAN=36
COLOR_GRAY=37
COLOR_WHITE=38
COLOR_NORMAL=0
COLOR_BOLD=1

# Echo a message in color
# $1 = COLOR_NORMAL or COLOR_BOLD
# $2 = COLOR_XXX
# $3 = message
echocolor() {
  B="$1"
  C="$2"
  shift 2
  echo -e -n "\e[${B};${C}m$@\e[0m"
}
# Same as echocolor but with a newline
# $1 = COLOR_NORMAL or COLOR_BOLD
# $2 = COLOR_XXX
# $3 = message
echocolornl() {
  B="$1"
  C="$2"
  shift 2
  echocolor "$B" "$C" "$@"
  echo
}
# Echo (with newline) an error message using color
# $@ = message
echoerror() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_BOLD $COLOR_RED "$@"
  fi
}
# Echo (with newline) a warning message using color
# $@ = message
echowarn() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_BOLD $COLOR_YELLOW "$@"
  fi
}
# Echo (with newline) an info message using color
# $@ = message
echoinfo() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_BOLD $COLOR_GREEN "$@"
  fi
}
# Echo (with newline) a simple normal message using color
# $@ = message
echon() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_NORMAL $COLOR_WHITE "$@"
  fi
}
# Echo (with newline) a debug message using color
# $@ = message
echodebug() {
  if [ -n "$SALT_DEBUG" -a -n "$1" ]; then
    echocolornl $COLOR_NORMAL $COLOR_YELLOW "$@"
  fi
}
# Append a message to log file /var/log/livedbg
# $@ = message
log() {
   echo "$@" 2>/dev/null >> /var/log/livedbg
}
# Same as doing echodebug + log
# $@ = message
debuglog() {
  if [ -n "$SALT_DEBUG" -a -n "$1" ]; then
    echodebug "$@" >&2
    log "DEBUG: $@"
  fi
}
# Same as doing echoinfo + log
# $@ = message
infolog() {
  if [ -n "$1" ]; then
    echoinfo "* $@"
    log "INFO: $@"
  fi
}
# Same as doing echowarn + log
# $@ = message
warnlog() {
  if [ -n "$1" ]; then
    if [ -n "$SALT_DEBUG" ]; then
      echowarn "* $@" >&2
    fi
    log "WARN: $@"
  fi
}
# Same as doing echowarn + log
# $@ = message
errorlog() {
  if [ -n "$1" ]; then
    echoerror "* $@" >&2
    log "ERROR: $@"
  fi
}
# Run an interactive shell if in debug, else do nothing
debugshell() {
  if [ -n "$SALT_DEBUG" ]; then
    echo
    echoinfo '  +-----------------------------+'
    echoinfo '  |       Debugging shell       |'
    echoinfo '  |   Hit Ctrl+D to continue    |'
    echoinfo '  +-----------------------------+'
    echo
    setsid hush -c 'exec hush </dev/tty1 >/dev/tty1 2>&1'
    echo
  fi
}
shell() {
  echo
  echoinfo '  +------------------------+'
  echoinfo '  |         Shell          |'
  echoinfo '  | Hit Ctrl+D to continue |'
  echoinfo '  +------------------------+'
  echo
  setsid hush -c 'exec hush </dev/tty1 >/dev/tty1 2>&1'
  echo
}
# Echo an error, try to run a shell, and the try to reboot
# $@ = optional message
fumble() {
  echo
  echoerror '  +-----------------------------+'
  echoerror '  |         Fatal Error         |'
  echoerror '  +-----------------------------+'
  echo
  [ -n "$1" ] && echocolor $COLOR_BOLD $COLOR_WHITE "$@"
  echo
  echoerror "Something went wrong and we can't continue. This should never happen."
  echoerror 'Please reboot your computer with Ctrl+Alt+Delete'
  echo
  setsid hush -c 'exec hush </dev/tty1 >/dev/tty1 2>&1' || sh
  exec reboot -f
}

# return succes (0) if the specified cheatcode is present on the Linux kernel command line
# $1 = cheatcode
is_on_cmdline() {
  grep -w -i -q "$1" /proc/cmdline
}
# return the value of the cheatcode on the Linux kernel commande line
# $1 = cheatcode
get_value_cmdline() {
  if grep -i -q " $1=" /proc/cmdline; then
    param=''
    lower=$(echo "$1"|tr A-Z a-z)
    upper=$(echo "$1"|tr a-z A-Z)
    i=1;
    n=$(expr length "$1")
    while [ $i -le $n ]; do
      param="$param["$(expr substr "$lower" $i 1)$(expr substr "$upper" $i 1)"]"
      i=$(($i + 1))
    done
    sed "s/.* $param=\([^ ]*\).*/\1/" /proc/cmdline
  fi
}

# Fix the IDENT_FILE variable using the optional command line option
get_ident_file() {
  ident_file=$(get_value_cmdline identfile)
  [ -n "$ident_file" ] && IDENT_FILE=$ident_file
  unset ident_file
  export IDENT_FILE
}

# Fix the IDENT_CONTENT variable using the optional command line option
get_ident_content() {
  ident_content=$(get_value_cmdline identcontent)
  [ -n "$ident_content" ] && IDENT_CONTENT=$ident_content
  unset ident_content
  export IDENT_CONTENT
}

# Fix the FROMISO variable using the optional command line option
get_fromiso() {
  fromiso=$(get_value_cmdline fromiso)
  [ -n "$fromiso" ] && FROMISO=$fromiso
  unset fromiso
  export FROMISO
}

# Fix the SAVE_FILE_NAME variable using the optional command line option
get_save_file_name() {
  save_file_name=$(get_value_cmdline savefile)
  [ -n "$save_file_name" ] && SAVE_FILE_NAME=$save_file_name
  unset save_file_name
  export SAVE_FILE_NAME
}

# Try to load a kernel module. Check if the module is builtin or not.
# If it's builtin do nothing, else modprobe it.
# $1 = module name
# $2+ = optional options to pass to the module
modprobe_check() {
  MODULE=$1
  shift
  debuglog "Loading $MODULE kernel module"
  OPTIONS="$*"
  MODULE2=$(echo $MODULE | tr '-' '_')
  grep -q "/$MODULE.ko\$" /lib/modules/$(uname -r)/modules.builtin 2>/dev/null || grep -q "/$MODULE2.ko\$" /lib/modules/$(uname -r)/modules.builtin 2>/dev/null
  if [ $? -eq 0 ]; then
    debuglog "  $MODULE is builtin"
  else
    if [ -n "$SALT_DEBUG" ]; then
      modprobe $MODULE $OPTIONS
    else
      modprobe $MODULE $OPTIONS >/dev/null 2>&1
    fi
  fi
}

# Load essential kernel modules, mainly filesystem modules.
load_core_modules() {
  modprobe_check loop
  modprobe_check isofs # for CD-ROM
  modprobe_check squashfs # for compressed readonly modules
  modprobe_check aufs brs=1 # for union fs
  modprobe_check ext2
  modprobe_check ext3
  modprobe_check ext4
  modprobe_check reiserfs
  modprobe_check xfs
  modprobe_check vfat # for fat16/fat32
  modprobe_check fuse # for ntfs-3g
}

# Initialize and populate /dev directory
init_dev() {
  mdev -s
}

# Load USB modules
load_usb_modules() {
  modprobe_check ehci-hcd
  modprobe_check ohci-hcd
  modprobe_check uhci-hcd
  modprobe_check usb-storage
  modprobe_check hid
  modprobe_check usbhid
  sleep 3
}

# Load PCMCIA modules
load_pcmcia_modules() {
  modprobe_check pcmcia_core # could be already loaded by ohci-hcd
  modprobe_check pcmcia # could be already loaded by ohci-hcd
  modprobe_check pcmcia_rsrc
  modprobe_check yenta_socket
}

# Show /dev/xxx devices, with optical devices first, and last USB connected devices first too.
# use a cache file (/tmp/devices) to improve performance.
find_mountable_devices() {
  if [ -e /tmp/devices ]; then
    cut -d: -f1 /tmp/devices
  else
    blkid|grep -v '^/dev/ram'|cut -d: -f1|sort -r|file -s -f -|tee /tmp/devices|cut -d: -f1
  fi
}

# Find the filesystem type as expected by "mount -t" of the specified device.
# $1 = device in the form /dev/xxx
find_fs_type() {
  echo "$1" | grep -q '^/dev/'
  if [ $? -eq 0 ]; then
    [ ! -e /tmp/devices ] && find_mountable_devices >/dev/null
    LINE=$(grep "^$1:" /tmp/devices|cut -d: -f2-)
    if echo "$LINE"|grep -i -q 'ISO 9660 CD-ROM'; then
      echo 'iso9660'
    elif echo "$LINE"|grep -i -q 'ext4 filesystem data'; then
      echo 'ext4'
    elif echo "$LINE"|grep -i -q 'ext3 filesystem data'; then
      echo 'ext3'
    elif echo "$LINE"|grep -i -q 'ext2 filesystem data'; then
      if echo "$LINE"|grep -i -q '(extents)'; then
        # false ext2 filesystem, it's actually ext4 filesystem without journal
        echo 'ext4'
      else
        echo 'ext2'
      fi
    elif echo "$LINE"|grep -i -q 'XFS filesystem data'; then
      echo 'xfs'
    elif echo "$LINE"|grep -i -q 'ReiserFS'; then
      echo 'reiserfs'
    elif echo "$LINE"|grep -i -q 'FAT'; then
      echo 'vfat'
    elif echo "$LINE"|grep -i -q 'NTFS'; then
      echo 'ntfs-3g'
    else
      warnlog "$1:$LINE: not supported filesystem"
      echo ''
    fi
  else
    debuglog "$1 no valid device, doesn't start with /dev"
  fi
}

# Find the options of the specified filesystem type.
# $1 = filesystem type
find_fs_options() {
  if [ "$1" = "iso9660" ]; then
    echo 'ro,relatime'
  elif [ "$1" = "ext4" -o "$1" = "ext3" -o "$1" = "ext2" ]; then
    echo 'noatime,defaults'
  elif [ "$1" = "xfs" ]; then
    echo 'noatime,defaults'
  elif [ "$1" = "reiserfs" ]; then
    echo 'noatime,defaults'
  elif [ "$1" = "vfat" ]; then
    echo 'noatime,defaults,quiet,umask=0,check=s,shortname=winnt,utf8,iocharset=utf8'
  elif [ "$1" = "ntfs-3g" ]; then
    echo 'umask=0'
  else
    echo ''
  fi
}

# Get the mount point that the device will be mounted to.
# $1 = device in the form /dev/xxx
get_mount_point() {
  echo "$1"|grep -q '^/dev/'
  if [ $? -eq 0 ]; then
    # Could be e.g. a subdirectory of /dev so replace additional slashes
    DEV=$(echo "$1"|sed -e 's:/dev/::' -e 's:/:_:g')
    echo /mnt/$DEV
  else
    debuglog "$1 no valid device, doesn't start with /dev"
  fi
}

# Mount the specified device and output the mount point.
# $1 = device in the form /dev/xxx
mount_device() {
  echo "$1"|grep -q '^/dev/'
  if [ $? -eq 0 ]; then
    # Could be e.g. a subdirectory of /dev so replace additional slashes
    DEV=$(echo "$1"|sed -e 's:/dev/::' -e 's:/:_:g')
    if mountpoint -q /mnt/$DEV; then
      debuglog "$1 already mounted on /mnt/$DEV"
    else
      TYPE=$(find_fs_type $1)
      [ -n "$TYPE" ] && TYPE_PART="-t $TYPE" || TYPE_PART=''
      OPTIONS=$(find_fs_options $TYPE)
      [ -n "$OPTIONS" ] && OPTIONS_PART="-o $OPTIONS" || OPTIONS_PART=''
      mkdir -p /mnt/$DEV
      debuglog "Mounting $1 on /mnt/$DEV with type '$TYPE' and options: '$OPTIONS'"
      mount $1 $TYPE_PART $OPTIONS_PART /mnt/$DEV >/dev/null 2>&1 && echo "/mnt/$DEV" || rmdir /mnt/$DEV
    fi
  else
    debuglog "$1 no valid device, doesn't start with /dev"
  fi
}

# Umount the specified device.
# $1 = device in the form /dev/xxx
umount_device() {
  echo "$1"|grep -q '^/dev/'
  if [ $? -eq 0 ]; then
    # Could be e.g. a subdirectory of /dev so replace additional slashes
    DEV=$(echo "$1"|sed -e 's:/dev/::' -e 's:/:_:g')
    if mountpoint -q /mnt/$DEV; then
      debuglog "Umounting /mnt/$DEV"
      umount -r -d /mnt/$DEV && rmdir /mnt/$DEV
      if mountpoint -q /mnt/$DEV; then
        debuglog "Umounting (force) /mnt/$DEV"
        umount -l -d /mnt/$DEV && rmdir /mnt/$DEV
      fi
    else
      debuglog "/mnt/$DEV is already umounted"
    fi
  else
    debuglog "$1 no valid device, doesn't start with /dev"
  fi
}

# Find the device and mount point where the distro resides.
# Will output in the format '/dev/xxx:/mnt/xxx' if found.
find_distro_device() {
  if [ -r /tmp/distro_infos ]; then # distro already mounted
    MP=$(cut -d: -f1 /tmp/distro_infos)
    d=$(cut -d: -f2- /tmp/distro_infos)
    ok=false
    if [ -e "$MP/$IDENT_FILE" ]; then
      unset ident_content
      eval $(grep "ident_content=" "$MP/$IDENT_FILE") || true
      if [ "$ident_content" = "$IDENT_CONTENT" ]; then
        echo "$MP:$d"
        ok=true
      fi
    fi
    if [ "$ok" = "false" ]; then
      debuglog "'/$IDENT_FILE:$IDENT_CONTENT' not found in $d"
      debuglog "Umounting $MP"
      (umount -r -d $MP && rmdir $MP) >/dev/null 2>&1
      if [ -e $MP ]; then
        (umount -l -d $MP && rmdir $MP) >/dev/null 2>&1
      fi
    fi
    unset ok
  fi
  if [ ! -r /tmp/distro_infos ]; then
    for d in $(find_mountable_devices); do
      MP=$(mount_device "$d")
      if [ -n "$MP" ]; then
        if [ -n "$FROMISO" ]; then
          if [ -e "$MP/$FROMISO" ]; then
            mkdir -p /mnt/fromiso
            mount -t iso9660 "$MP/$FROMISO" /mnt/fromiso -o loop,ro
            echo "/mnt/fromiso:$MP/$FROMISO"|tee /tmp/distro_infos
            break
          fi
        else
          if [ -e "$MP/$IDENT_FILE" ]; then
            unset ident_content
            eval $(grep "ident_content=" "$MP/$IDENT_FILE") || true
            if [ "$ident_content" = "$IDENT_CONTENT" ]; then
              echo "$MP:$d"|tee /tmp/distro_infos
              break
            fi
          fi
        fi
        debuglog "'/$IDENT_FILE:$IDENT_CONTENT' not found in $d"
        umount_device "$d" >/dev/null 2>&1
      fi
    done
  fi
}

# Prints the basedir from the ident file to stdout.
# Assure it starts with / and does not end with /
# $1 = mount point of the distro
get_basedir() {
  if [ ! -e "$1/$IDENT_FILE" ]; then
    warnlog "When determining the basedir, '$1/$IDENT_FILE' was not found"
    return 1
  fi
  eval $(grep "basedir=" "$1/$IDENT_FILE") || true
  if [ -z "$basedir" ]; then
    warnlog "Basedir was not set in the ident file or is empty"
    return 1
  fi
  # add a leading slash if needed and remove the ending slash if present
  echo "$basedir"|sed 's:^[^/]:/&:; s:\(.\)/$:\1:'
  unset basedir
  return 0
}

# Find the save file if it exists.
# First search on the distro device then on others partitions.
# $1 = mount point of the distro
find_save_file() {
  basedir="$(get_basedir "$1" || echo '/')"
  for d in "$1" $(find_mountable_devices); do
    if [ -d "$d" ]; then
      MP="$d"
    else
      MP=$(mount_device "$d")
      if [ "$MP" = "$d" ]; then
        continue
      fi
    fi
    if [ -n "$MP" ]; then
      if [ -f "$MP$basedir/$ROOT_DIR/persistence/$SAVE_FILE_NAME" ]; then
        file "$MP$basedir/$ROOT_DIR/persistence/$SAVE_FILE_NAME"|grep -q -i 'SGI XFS filesystem data\|Linux rev 1\.0 ext. filesystem\|ReiserFS\|, FAT \|, OEM-ID "NTFS'
        if [ $? -eq 0 ]; then
          echo "$MP$basedir/$ROOT_DIR/persistence/$SAVE_FILE_NAME"
          break
        fi
      fi
      debuglog "'$basedir/$ROOT_DIR/persistence/$SAVE_FILE_NAME' not found in $d"
      if [ ! -d "$d" ]; then
        umount_device "$d" >/dev/null 2>&1
      fi
    fi
  done
}

# Create a union filesystem.
# The current implementation use aufs2.
# The union is done in /mnt/union which is created if it not exists.
# $1 = writable mount point branch
create_union() {
  RW="$1"
  if [ -d "$RW" ]; then
    touch "$RW/testrw" 2>/dev/null
    if [ -e "$RW/testrw" ]; then
      rm "$RW/testrw"
      [ ! -e /mnt/union ] && mkdir -p /mnt/union
      [ ! -e /mnt/xino ] && mkdir -p /mnt/xino
      mount -t tmpfs none /mnt/xino
      mount -t aufs -o nowarn_perm,noplink,xino=/mnt/xino/.aufs.xino,br="$RW" none /mnt/union
    else
      errorlog "create_union: $RW is not writable"
      return 1
    fi
  else
    errorlog "create_union: $RW is not a directory"
    return 1
  fi
}

# Destroy the union filesystem.
# The current implementation use aufs2.
# The union is destroy from /mnt/union.
destroy_union() {
  if [ -e /mnt/union ]; then
    if mountpoint -q /mnt/union; then
      umount -r -d /mnt/union 2>/dev/null
      if mountpoint -q /mnt/union; then
        umount -l -d /mnt/union 2>/dev/null
      fi
    fi
    umount /mnt/xino
    rmdir /mnt/union /mnt/xino
  fi
}

# Find modules to load in the union filesystem.
# The modules must be in $ROOT_DIR/modules/ and must have .salt extension
# $1 = mount point of the distro
find_modules() {
  MP="$1"
  if [ -n "$MP" ]; then
    basedir="$(get_basedir "$MP" || echo '/')"
    if [ -d "$MP$basedir/$ROOT_DIR/modules" ]; then
      for m in "$MP$basedir/$ROOT_DIR"/modules/*.salt; do
        file "$m"|grep -i -q 'Squashfs filesystem' && echo "$m"
      done
    else
      errorlog "'$MP$basedir/$ROOT_DIR/modules' not found"
      return 1
    fi
  fi
}

# Add a module (squashfs filesystem) to the union filesystem.
# The current implementation use aufs2.
# $1 = module file to load
load_module() {
  m="$1"
  if [ -e "$m" ]; then
    if mountpoint -q /mnt/union; then
      file "$m"|grep -i -q 'Squashfs filesystem'
      if [ $? -eq 0 ]; then
        n=$(basename "$m" .salt)
        mp="/mnt/modules/$n"
        mkdir -p "$mp"
        if is_on_cmdline 'memonly'; then
          mkdir -p /tmp/modules
          debuglog "copying $m to /tmp/modules/..."
          cp "$m" /tmp/modules/
          m="/tmp/modules/$(basename "$m")"
        fi
        mount -t squashfs -o loop "$m" "$mp"
        if [ $? -eq 0 ]; then
          mount -o remount,nowarn_perm,add:1:"$mp"=ro /mnt/union >/dev/null || return 1
        else
          return 1
        fi
      else
        return 1
      fi
    else
      errorlog "load_module: /mnt/union is not mounted, please call create_union first."
      return 1
    fi
  else
    errorlog "load_module: '$m' not found"
    return 1
  fi
}

# Try loading rootcopy.tar or rootcopy directory to the union filesystem
# The archive or directory must be in $ROOT_DIR/
# $1 = mount point of the distro
load_rootcopy() {
  MP="$1"
  if [ -n "$MP" ]; then
    basedir="$(get_basedir "$MP" || echo '/')"
    if [ -f "$MPbasedir/$ROOT_DIR/rootcopy.tar" ]; then
      debuglog "'$MP$basedir/$ROOT_DIR/rootcopy.tar' found, copying content to /mnt/union/"
      # ensure to not write outside of /mnt/rw/ while untaring
      tar -C /mnt/union -p -x -f $MP$basedir/$ROOT_DIR/rootcopy.tar ./
    elif [ -d "$MP$basedir/$ROOT_DIR/rootcopy" ]; then
      debuglog "'$MP$basedir/$ROOT_DIR/rootcopy' found, copying content to /mnt/union/"
      # ensure to also copy hidden files
      cp -r $MP$basedir/$ROOT_DIR/rootcopy/. /mnt/union/
    fi
  fi
}

# Remove a module from the union filesystem.
# The current implementation use aufs2.
# $1 = mount point used in the union
unload_module() {
  mp="$1"
  if [ -d "$mp" ]; then
    if mountpoint -q /mnt/union && mountpoint -q "$mp"; then
      mount -o remount,del:"$mp" /mnt/union >/dev/null
      if [ $? -eq 0 ]; then
        umount -r -d "$mp"
      else
        return 1
      fi
      rmdir "$mp" || return 1
    else
      errorlog "unload_module: /mnt/union or $mp is not mounted."
      return 1
    fi
  else
    errorlog "unload_module: '$mp' not found"
    return 1
  fi
}

# Install hookers for cleanup.
# $1 = mount point
install_hookers() {
  MP="$1"
  if [ ! -e "$MP/hooks.salt" ]; then
    mkdir -p "$MP/hooks"
    echo "#DO NOT REMOVE THIS FILE" > "$MP/hooks.salt"
    for b in halt poweroff reboot; do
      for d in sbin usr/sbin; do
        if [ -x "$MP/$d/$b" -o -L "$MP/$d/$b" ]; then
          debuglog "  - Hook for $b in /$d installed"
          mv "$MP/$d/$b" "$MP/hooks/"
          (cd "$MP/$d"; ln -s /mnt/salt/cleanup "$b")
        fi
      done
    done
  fi
}

# Change root for another process that will replace current process.
# The current directory should be positionned as the new root.
# $1 = new root
# $2 = directory in the new root for referencing the old root
# $3+ = command line to run. $1 must be a valid executable in the new root.
change_root_to() {
  NEW_ROOT="$1"
  OLD_ROOT="$2"
  shift
  shift
  debuglog "change_root_to: newroot=$NEW_ROOT oldroot=$OLD_ROOT args=$@"
  cd "$NEW_ROOT"
  mkdir -p "$OLD_ROOT"
  debuglog "remounting $NEW_ROOT readonly"
  mount -o remount,ro .
  pivot_root . "$OLD_ROOT"
  exec chroot . "$@" <./dev/console >./dev/console 2>&1
  echoerror "Chroot to $PWD failed"
}
# chroot in the distro
# $@ = command line to run. $1 must be a valid executable in the new root.
change_root_to_distro() {
  if mountpoint -q /mnt/union; then
    change_root_to /mnt/union mnt/salt "$@"
  else
    echoerror '/mnt/union not mounted'
  fi
}
# chroot back in the initrd
# $@ = command line to run. $1 must be a valid executable in the new root.
change_root_to_initrd() {
  if [ -e /mnt/salt/tmp/distro_infos ]; then
    change_root_to /mnt/salt mnt/union "$@"
  else
    echoerror '/mnt/salt/tmp/distro_infos file cannot be found'
  fi
}

# Kill all process where the PID is before the specified PID.
# Process with PID 1 is ignore.
# Every process parent of the given pid will also be ignored.
# Kernel thread process are ignored too.
# Some process are ignored: mount*, ntfs*
# $1 = maximum pid
kill_all_before() {
  PID=$1
  echodebug "kill all before $PID"
  ignorelst=:
  ignore=$PID
  while [ $ignore -gt 1 ]; do
    # don't ignore processes referencing /mnt/union
    grep -q /mnt/union /proc/$ignore/maps && break
    ignorelst="$ignorelst$ignore:"
    ignore=$(grep '^PPid:' /proc/$ignore/status|sed 's/.*:[ \t]*//')
  done
  echodebug "ignorelst $ignorelst"
  lst=
  for pid in $(ps|grep -v 'PID USER'|grep -v ' \[[^ ]*\]$'|grep -v mount|grep -v ntfs|cut -d' ' -f2|sort -r); do
    if [ $pid -lt $PID -a $pid -gt 1 -a -z "$(echo $ignorelst|grep :$pid:)" ]; then
      lst="$lst $pid"
    fi
  done
  echodebug "kill list: $lst"
  debugshell
  if [ -n "$lst" ]; then
    echodebug "kill -15 $lst"
    kill -15 $lst 2>/dev/null
    sleep 1
    echodebug "kill -9  $lst"
    kill -9  $lst 2>/dev/null
    sleep 1
  fi
  PPID=$(grep '^PPid:' /proc/$PID/status|grep -o '[0-9]*')
  echodebug "kill -9 $PPID"
  kill -9 $PPID
  # because init will print a message without a new line
  sleep .1
  echo
}

# Umount all sub-mounts that appear inside the specified mountpoint.
# $1 = mount point
umount_submounts_in() {
  MP="$1"
  for d in $(mount|grep " $MP/"|sed "s:.* \($MP/[^ ]\+\) .*:\1:"|sort -r); do
    debuglog "  - Umount $d"
    umount -r -d $d 2>/dev/null
  done
  for d in $(mount|grep " $MP/"|sed "s:.* \($MP/[^ ]\+\) .*:\1:"|sort -r); do
    debuglog "  - Umount $d (force)"
    umount -l -d $d 2>/dev/null
  done
}

# Eject the CD if the source is a CD
eject_cd() {
  DEV=$(cut -d: -f2- /tmp/distro_infos)
  TYPE=$(find_fs_type $DEV)
  if [ "$TYPE" = "iso9660" ]; then
    echoinfo "Ejecting $DEV..."
    eject $DEV 2>/dev/null
    echoinfo "CD tray will be closed in 10 seconds or hit enter..."
    for i in $(seq 1 10); do echo -n .; read -t 1 && break; done
    echo
    eject -t $DEV 2>/dev/null
  fi
}
