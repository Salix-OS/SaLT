#!/bin/sh
# vim: set syn=sh ai et sw=2 st=2 ts=2 tw=0:
#
# This file is part of SaLT.
# Copyright: Cyrille Pontvieux <jrd@salixos.org>
# Licence: GPLv3+
# Version: 0.1
# Library for use by init and cleanup

if [ -f /etc/salt.cfg ]; then
  . /etc/salt.cfg
elif [ -f /mnt/salt/etc/salt.cfg ]; then
  . /mnt/salt/etc/salt.cfg
else
  echo "salt.cfg not found, cannot proceed further" >&2
  return 1
fi

# debug mode is done using kernel command line or by putting something in the file /SALT_DEBUG
SALT_DEBUG=$(cat /proc/cmdline 2>/dev/null | grep -q -w -i debug && echo 1 || cat /SALT_DEBUG /mnt/salt/SALT_DEBUG 2>/dev/null)
export SALT_DEBUG
SAVE_FILE_NAME=${ROOT_DIR}.save
export SAVE_FILE_NAME

COLOR_BLACK=30
COLOR_RED=31
COLOR_GREEN=32
COLOR_YELLOW=33
COLOR_BLUE=34
COLOR_MAGENTA=35
COLOR_CYAN=36
COLOR_GRAY=37
COLOR_WHITE=38
COLOR_NORMAL=0
COLOR_BOLD=1

# Echo a message in color
# $1 = COLOR_NORMAL or COLOR_BOLD
# $2 = COLOR_XXX
# $3 = message
echocolor() {
  B="$1"
  C="$2"
  shift 2
  echo -e -n "\e[${B};${C}m$@\e[0m"
}
# Same as echocolor but with a newline
# $1 = COLOR_NORMAL or COLOR_BOLD
# $2 = COLOR_XXX
# $3 = message
echocolornl() {
  B="$1"
  C="$2"
  shift 2
  echocolor "$B" "$C" "$@"
  echo
}
# Echo (with newline) an error message using color
# $@ = message
echoerror() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_BOLD $COLOR_RED "$@"
  fi
}
# Echo (with newline) a warning message using color
# $@ = message
echowarn() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_BOLD $COLOR_YELLOW "$@"
  fi
}
# Echo (with newline) an info message using color
# $@ = message
echoinfo() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_BOLD $COLOR_GREEN "$@"
  fi
}
# Echo (with newline) a simple normal message using color
# $@ = message
echon() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_NORMAL $COLOR_WHITE "$@"
  fi
}
# Echo (with newline) a debug message using color
# $@ = message
echodebug() {
  if [ -n "$SALT_DEBUG" -a -n "$1" ]; then
    echocolornl $COLOR_NORMAL $COLOR_YELLOW "$@"
  fi
}
# Append a message to log file /var/log/livedbg
# $@ = message
log() {
   echo "$@" 2>/dev/null >> /var/log/livedbg
}
# Same as doing echodebug + log
# $@ = message
debuglog() {
  if [ -n "$SALT_DEBUG" -a -n "$1" ]; then
    echodebug "$@" >&2
    log "DEBUG: $@"
  fi
}
# Same as doing echoinfo + log
# $@ = message
infolog() {
  if [ -n "$1" ]; then
    echoinfo "* $@"
    log "INFO: $@"
  fi
}
# Same as doing echowarn + log
# $@ = message
warnlog() {
  if [ -n "$1" ]; then
    echowarn "* $@" >&2
    log "WARN: $@"
  fi
}
# Same as doing echowarn + log
# $@ = message
errorlog() {
  if [ -n "$1" ]; then
    echoerror "* $@" >&2
    log "ERROR: $@"
  fi
}
# Run an interactive shell if in debug, else do nothing
debugshell() {
  if [ -n "$SALT_DEBUG" ]; then
    echo
    echoinfo '  +-----------------------------+'
    echoinfo '  |       Debugging shell       |'
    echoinfo '  |   Hit Ctrl+D to continue    |'
    echoinfo '  +-----------------------------+'
    echo
    setsid sh -c 'exec hush </dev/tty1 >/dev/tty1 2>&1'
    echo
  fi
}
shell() {
  echo
  echoinfo '  +------------------------+'
  echoinfo '  |         Shell          |'
  echoinfo '  | Hit Ctrl+D to continue |'
  echoinfo '  +------------------------+'
  echo
  setsid sh -c 'exec hush </dev/tty1 >/dev/tty1 2>&1'
  echo
}
# Echo an error, try to run a shell, and the try to reboot
# $@ = optional message
fumble() {
  echo
  echoerror '  +-----------------------------+'
  echoerror '  |         Fatal Error         |'
  echoerror '  +-----------------------------+'
  echo
  [ -n "$1" ] && echocolor $COLOR_BOLD $COLOR_WHITE "$@"
  echo
  echoerror "Something went wrong and we can't continue. This should never happen."
  echoerror 'Please reboot your computer with Ctrl+Alt+Delete'
  echo
  setsid sh -c 'exec hush </dev/tty1 >/dev/tty1 2>&1' || sh
  exec reboot -f
}

# return succes (0) if the specified cheatcode is present on the Linux kernel command line
# $1 = cheatcode
is_on_cmdline() {
  grep -w -i -q "$1" /proc/cmdline
}
# return the value of the cheatcode on the Linux kernel commande line
# $1 = cheatcode
get_value_cmdline() {
  if grep -i -q " $1=" /proc/cmdline; then
    param=''
    lower=$(echo "$1"|tr A-Z a-z)
    upper=$(echo "$1"|tr a-z A-Z)
    i=1;
    n=$(expr length "$1")
    while [ $i -le $n ]; do
      param="$param["$(expr substr "$lower" $i 1)$(expr substr "$upper" $i 1)"]"
      i=$(($i + 1))
    done
    sed "s/.* $param=\([^ ]*\).*/\1/" /proc/cmdline
  fi
}

# Try to load a kernel module. Check if the module is builtin or not.
# If it's builtin do nothing, else modprobe it.
# $1 = module name
# $2+ = optional options to pass to the module
modprobe_check() {
  MODULE=$1
  shift
  debuglog "Loading $MODULE kernel module"
  OPTIONS="$*"
  MODULE2=$(echo $MODULE | tr '-' '_')
  grep -q "/$MODULE.ko\$" /lib/modules/$(uname -r)/modules.builtin 2>/dev/null || grep -q "/$MODULE2.ko\$" /lib/modules/$(uname -r)/modules.builtin 2>/dev/null
  if [ $? -eq 0 ]; then
    debuglog "  $MODULE is builtin"
  else
    if [ -n "$SALT_DEBUG" ]; then
      modprobe $MODULE $OPTIONS
    else
      modprobe $MODULE $OPTIONS >/dev/null 2>&1
    fi
  fi
}

# Load essential kernel modules, mainly filesystem modules.
load_core_modules() {
  modprobe_check loop
  modprobe_check isofs # for CD-ROM
  modprobe_check squashfs # for compressed readonly modules
  modprobe_check aufs brs=1 # for union fs
  modprobe_check ext2
  modprobe_check ext3
  modprobe_check ext4
  modprobe_check reiserfs
  modprobe_check xfs
  modprobe_check vfat # for fat16/fat32
  modprobe_check fuse # for ntfs-3g
}

# Initialize and populate /dev directory
init_dev() {
  mdev -s
}

# Load USB modules
load_usb_modules() {
  lspciusb=$(lspci -v | grep -i prog-if)
  found=
  if [ -n "$(echo $lspciusb | grep -i ehci)" ]; then
    modprobe_check ehci-hcd
    found=y
  fi
  if [ -n "$(echo $lspciusb | grep -i ohci)" ]; then
    modprobe_check ohci-hcd
    found=y
  fi
  if [ -n "$(echo $lspciusb | grep -i uhci)" ]; then
    modprobe_check uhci-hcd
    found=y
  fi
  if [ -n "$found" ]; then
    modprobe_check usb-storage
  fi
}

# Load PCMCIA modules
load_pcmcia_modules() {
  modprobe_check pcmcia_core # could be already loaded by ohci-hcd
  modprobe_check pcmcia # could be already loaded by ohci-hcd
  modprobe_check pcmcia_rsrc
  modprobe_check yenta_socket
}

# Show /dev/xxx devices, with optical devices first, and last USB connected devices first too.
# use a cache file (/tmp/devices) to improve performance.
find_mountable_devices() {
  if [ -e /tmp/devices ]; then
    cut -d: -f1 /tmp/devices
  else
    blkid|grep -v '^/dev/ram'|cut -d: -f1|sort -r|file -s -f -|tee /tmp/devices|cut -d: -f1
  fi
}

# Find the filesystem type as expected by "mount -t" of the specified device.
# $1 = device in the form /dev/xxx
find_fs_type() {
  echo "$1" | grep -q '^/dev/'
  if [ $? -eq 0 ]; then
    [ ! -e /tmp/devices ] && find_mountable_devices >/dev/null
    LINE=$(grep "^$1:" /tmp/devices|cut -d: -f2-)
    if echo "$LINE"|grep -i -q 'ISO 9660 CD-ROM'; then
      echo 'iso9660'
    elif echo "$LINE"|grep -i -q 'ext4 filesystem data'; then
      echo 'ext4'
    elif echo "$LINE"|grep -i -q 'ext3 filesystem data'; then
      echo 'ext3'
    elif echo "$LINE"|grep -i -q 'ext2 filesystem data'; then
      echo 'ext2'
    elif echo "$LINE"|grep -i -q 'XFS filesystem data'; then
      echo 'xfs'
    elif echo "$LINE"|grep -i -q 'ReiserFS'; then
      echo 'reiserfs'
    elif echo "$LINE"|grep -i -q 'FAT'; then
      echo 'vfat'
    elif echo "$LINE"|grep -i -q 'NTFS'; then
      echo 'ntfs-3g'
    else
      warnlog "$1:$LINE: not supported filesystem"
      echo ''
    fi
  else
    echo ''
  fi
}

# Find the options of the specified filesystem type.
# $1 = filesystem type
find_fs_options() {
  if [ "$1" = "iso9660" ]; then
    echo 'ro,relatime'
  elif [ "$1" = "ext4" -o "$1" = "ext3" -o "$1" = "ext2" ]; then
    echo 'noatime,defaults'
  elif [ "$1" = "xfs" ]; then
    echo 'noatime,defaults'
  elif [ "$1" = "reiserfs" ]; then
    echo 'noatime,defaults'
  elif [ "$1" = "vfat" ]; then
    echo 'noatime,defaults,quiet,umask=0,check=s,shortname=winnt,utf8,iocharset=utf8'
  elif [ "$1" = "ntfs-3g" ]; then
    echo 'umask=0'
  else
    echo ''
  fi
}

# Mount the specified device and output the mount point.
# $1 = device in the form /dev/xxx
mount_device() {
  echo "$1"|grep -q '^/dev/'
  if [ $? -eq 0 ]; then
    DEV=$(echo "$1"|sed 's:/dev/::')
    if mountpoint -q /mnt/$DEV; then
      debuglog "/dev/$DEV already mounted on /mnt/$DEV"
    else
      TYPE=$(find_fs_type /dev/$DEV)
      OPTIONS=$(find_fs_options $TYPE)
      mkdir -p /mnt/$DEV
      debuglog "Mounting /dev/$DEV on /mnt/$DEV with type $TYPE and options: $OPTIONS"
      mount /dev/$DEV -t "$TYPE" -o "$OPTIONS" /mnt/$DEV >/dev/null 2>&1 && echo "/mnt/$DEV" || rmdir /mnt/$DEV
    fi
  fi
}

# Umount the specified device.
# $1 = device in the form /dev/xxx
umount_device() {
  echo "$1"|grep -q '^/dev/'
  if [ $? -eq 0 ]; then
    DEV=$(echo "$1"|sed 's:/dev/::')
    if mountpoint -q /mnt/$DEV; then
      debuglog "Umounting /mnt/$DEV"
      (umount -r -d /mnt/$DEV || umount -l /mnt/$DEV) && rmdir /mnt/$DEV
    else
      debuglog "/mnt/$DEV is already umounted"
    fi
  fi
}

# Find the device and mount point where the distro resides.
# Will output in the format '/dev/xxx:/mnt/xxx' if found.
find_distro_device() {
  if [ -r /tmp/distro_infos ]; then # distro already mounted
    MP=$(cut -d: -f1 /tmp/distro_infos)
    d=$(cut -d: -f2- /tmp/distro_infos)
    ok=false
    if [ -e "$MP/$IDENT_FILE" ]; then
      C="$(cat "$MP/$IDENT_FILE")"
      if [ "$C" = "$IDENT_CONTENT" ]; then
        echo "$MP:$d"
        ok=true
      fi
    fi
    if [ "$ok" = "false" ]; then
      debuglog "'/$IDENT_FILE:$IDENT_CONTENT' not found in $d"
      debuglog "Umounting $MP"
      ((umount -r -d $MP || umount -l $MP) && rmdir $MP) >/dev/null 2>&1
    fi
    unset ok
  fi
  if [ ! -r /tmp/distro_infos ]; then
    for d in $(find_mountable_devices); do
      MP=$(mount_device "$d")
      if [ -n "$MP" ]; then
        if [ -e "$MP/$IDENT_FILE" ]; then
          C="$(cat "$MP/$IDENT_FILE")"
          if [ "$C" = "$IDENT_CONTENT" ]; then
            echo "$MP:$d"|tee /tmp/distro_infos
            break
          fi
        fi
        debuglog "'/$IDENT_FILE:$IDENT_CONTENT' not found in $d"
        umount_device "$d" >/dev/null 2>&1
      fi
    done
  fi
}

# Find the save file if it exists.
# First search on the distro device then on others partitions.
# $1 = mount point of the distro
find_save_file() {
  for d in "$1" $(find_mountable_devices); do
    if [ -d "$d" ]; then
      MP="$d"
    else
      MP=$(mount_device "$d")
      if [ "$MP" = "$d" ]; then
        continue
      fi
    fi
    if [ -n "$MP" ]; then
      if [ -f "$MP/$ROOT_DIR/$SAVE_FILE_NAME" ]; then
        file "$MP/$ROOT_DIR/$SAVE_FILE_NAME"|grep -q -i 'SGI XFS filesystem data\|Linux rev 1\.0 ext. filesystem\|ReiserFS\|, FAT \|, OEM-ID "NTFS'
        if [ $? -eq 0 ]; then
          echo "$MP/$ROOT_DIR/$SAVE_FILE_NAME"
          break
        fi
      fi
      debuglog "'/$ROOT_DIR/$SAVE_FILE_NAME' not found in $d"
      if [ ! -d "$d" ]; then
        umount_device "$d" >/dev/null 2>&1
      fi
    fi
  done
}

# Create a union filesystem.
# The current implementation use aufs2.
# The union is done in /mnt/union which is created if it not exists.
# $1 = writable mount point branch
create_union() {
  RW="$1"
  if [ -d "$RW" ]; then
    touch "$RW/testrw" 2>/dev/null
    if [ -e "$RW/testrw" ]; then
      rm "$RW/testrw"
      [ ! -e /mnt/union ] && mkdir -p /mnt/union
      [ ! -e /mnt/xino ] && mkdir -p /mnt/xino
      mount -t tmpfs none /mnt/xino
      mount -t aufs -o nowarn_perm,noplink,xino=/mnt/xino/.aufs.xino,br="$RW" none /mnt/union
    else
      errorlog "create_union: $RW is not writable"
      return 1
    fi
  else
    errorlog "create_union: $RW is not a directory"
    return 1
  fi
}

# Destroy the union filesystem.
# The current implementation use aufs2.
# The union is destroy from /mnt/union.
destroy_union() {
  if [ -e /mnt/union ]; then
    if mountpoint -q /mnt/union; then
      umount -r -d /mnt/union || umount -l /mnt/union 2>/dev/null
    fi
    umount /mnt/xino
    rmdir /mnt/union /mnt/xino
  fi
}

# Find modules to load in the union filesystem.
# The modules must be in $ROOT_DIR/modules/ and must have .salt extension
# $1 = mount point of the distro
find_modules() {
  MP="$1"
  if [ -n "$MP" ]; then
    if [ -d "$MP/$ROOT_DIR/modules" ]; then
      for m in "$MP/$ROOT_DIR"/modules/*.salt; do
        file "$m"|grep -i -q 'Squashfs filesystem' && echo "$m"
      done
    else
      errorlog "'$MP/$ROOT_DIR/modules' not found"
      return 1
    fi
  fi
}

# Add a module (squashfs filesystem) to the union filesystem.
# The current implementation use aufs2.
# $1 = module file to load
load_module() {
  m="$1"
  if [ -e "$m" ]; then
    if mountpoint -q /mnt/union; then
      file "$m"|grep -i -q 'Squashfs filesystem'
      if [ $? -eq 0 ]; then
        n=$(basename "$m" .salt)
        mp="/mnt/modules/$n"
        mkdir -p "$mp"
        if is_on_cmdline 'memonly'; then
          mkdir -p /tmp/modules
          debuglog "copying $m to /tmp/modules/..."
          cp "$m" /tmp/modules/
          m="/tmp/modules/$(basename "$m")"
        fi
        mount -t squashfs -o loop "$m" "$mp"
        if [ $? -eq 0 ]; then
          mount -o remount,nowarn_perm,add:1:"$mp"=ro /mnt/union >/dev/null || return 1
        else
          return 1
        fi
      else
        return 1
      fi
    else
      errorlog "load_module: /mnt/union is not mounted, please call create_union first."
      return 1
    fi
  else
    errorlog "load_module: '$m' not found"
    return 1
  fi
}

# Remove a module from the union filesystem.
# The current implementation use aufs2.
# $1 = mount point used in the union
unload_module() {
  mp="$1"
  if [ -d "$mp" ]; then
    if mountpoint -q /mnt/union && mountpoint -q "$mp"; then
      mount -o remount,del:"$mp" /mnt/union >/dev/null
      if [ $? -eq 0 ]; then
        umount -r -d "$mp"
      else
        return 1
      fi
      rmdir "$mp" || return 1
    else
      errorlog "unload_module: /mnt/union or $mp is not mounted."
      return 1
    fi
  else
    errorlog "unload_module: '$mp' not found"
    return 1
  fi
}

# Install hookers for cleanup.
# $1 = mount point
install_hookers() {
  MP="$1"
  mkdir -p "$MP/hooks"
  echo "#DO NOT REMOVE THIS FILE" > "$MP/hooks.salt"
  for b in halt poweroff reboot; do
    for d in sbin usr/sbin; do
      if [ -x "$MP/$d/$b" -o -L "$MP/$d/$b" ]; then
        debuglog "  - Hook for $b in /$d installed"
        mv "$MP/$d/$b" "$MP/hooks/"
        (cd "$MP/$d"; ln -s /mnt/salt/cleanup "$b")
        cat <<EOF >> "$MP/hooks.salt"
[ -e "hooks/$b" ] && mv "hooks/$b" "$d/"

EOF
      fi
    done
  done
  echo '[ -d hooks ] && rm -rf hooks' >> "$MP/hooks.salt"
}

# Uninstall hookers for cleanup.
# $1 = mount point
uninstall_hookers() {
  MP="$1"
  if [ -e "$MP/hooks.salt" ]; then
    ( cd "$MP"; sh hooks.salt )
    rm "$MP/hooks.salt"
  fi
}

# Change root for another process that will replace current process.
# The current directory should be positionned as the new root.
# $1 = new root
# $2 = directory in the new root for referencing the old root
# $3+ = command line to run. $1 must be a valid executable in the new root.
change_root_to() {
  NEW_ROOT="$1"
  OLD_ROOT="$2"
  shift
  shift
  debuglog "change_root_to: newroot=$NEW_ROOT oldroot=$OLD_ROOT args=$@"
  cd "$NEW_ROOT"
  mkdir -p "$OLD_ROOT"
  debuglog "remounting $NEW_ROOT readonly"
  mount -o remount,ro .
  pivot_root . "$OLD_ROOT"
  exec chroot . "$@" <./dev/console >./dev/console 2>&1
  echoerror "Chroot to $PWD failed"
}
# chroot in the distro
# $@ = command line to run. $1 must be a valid executable in the new root.
change_root_to_distro() {
  if mountpoint -q /mnt/union; then
    change_root_to /mnt/union mnt/salt "$@"
  else
    echoerror '/mnt/union not mounted'
  fi
}
# chroot back in the initrd
# $@ = command line to run. $1 must be a valid executable in the new root.
change_root_to_initrd() {
  if [ -e /mnt/salt/tmp/distro_infos ]; then
    change_root_to /mnt/salt mnt/union "$@"
  else
    echoerror '/mnt/salt/tmp/distro_infos file cannot be found'
  fi
}

# Kill all process where the PID is before the specified PID.
# Process with PID 1 is ignore.
# Kernel thread process are ignored too.
# Some process are ignored: mount, ntfs
# $1 = maximum pid
kill_all_before() {
  PID=$1
  lst=
  for pid in $(ps|grep -v 'PID USER'|grep -v ' \[[^ ]*\]$'|grep -v mount|grep -v ntfs|cut -d' ' -f2|sort -r); do
    if [ $pid -lt $PID -a $pid -ne 1 ]; then
      lst="$lst $pid"
    fi
  done
  kill -15 $lst 2>/dev/null
  sleep 1
  kill -9  $lst 2>/dev/null
}

# Umount all sub-mounts that appear inside the specified mountpoint.
# $1 = mount point
umount_submounts_in() {
  MP="$1"
  for d in $(mount|grep " $MP/"|sed "s:.* \($MP/[^ ]\+\) .*:\1:"|sort -r); do
    debuglog "  - Umount $d"
    umount -r -d $d || umount -l $d 2>/dev/null
  done
}

# Eject the CD if the source is a CD
eject_cd() {
  DEV=$(cut -d: -f2- /tmp/distro_infos)
  TYPE=$(find_fs_type $DEV)
  if [ "$TYPE" = "iso9660" ]; then
    echoinfo "Ejecting $DEV..."
    eject $DEV 2>/dev/null
    echoinfo "CD tray will be closed in 10 seconds or hit enter..."
    for i in $(seq 1 10); do echo -n .; read -t 1 && break; done
    echo
    eject -t $DEV 2>/dev/null
  fi
}
