#!/bin/sh
# vim: set syn=sh ai et sw=2 st=2 ts=2 tw=0:

if [ -f /etc/salt.cfg ]; then
  . /etc/salt.cfg
elif [ -f /mnt/salt/etc/salt.cfg ]; then
  . /mnt/salt/etc/salt.cfg
else
  echo "salt.cfg not found, cannot proceed further" >&2
  exit 1
fi

# debug mode is done using kernel command line or by putting something in the file /SALT_DEBUG
SALT_DEBUG=$(cat /proc/cmdline 2>/dev/null | grep debug >/dev/null && echo 1 || cat /SALT_DEBUG 2>/dev/null)

COLOR_BLACK=30
COLOR_RED=31
COLOR_GREEN=32
COLOR_YELLOW=33
COLOR_BLUE=34
COLOR_MAGENTA=35
COLOR_CYAN=36
COLOR_GRAY=37
COLOR_WHITE=38
COLOR_NORMAL=0
COLOR_BOLD=1

# Echo a message in color
# $1 = COLOR_NORMAL or COLOR_BOLD
# $2 = COLOR_XXX
# $3 = message
echocolor() {
  B="$1"
  C="$2"
  shift 2
  echo -e -n "\e[${B};${C}m$@\e[0m"
}
# Same as echocolor but with a newline
# $1 = COLOR_NORMAL or COLOR_BOLD
# $2 = COLOR_XXX
# $3 = message
echocolornl() {
  B="$1"
  C="$2"
  shift 2
  echocolor "$B" "$C" "$@"
  echo
}
# Echo (with newline) an error message using color
# $@ = message
echoerror() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_BOLD $COLOR_RED "$@"
  fi
}
# Echo (with newline) a warning message using color
# $@ = message
echowarn() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_BOLD $COLOR_YELLOW "$@"
  fi
}
# Echo (with newline) an info message using color
# $@ = message
echoinfo() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_BOLD $COLOR_GREEN "$@"
  fi
}
# Echo (with newline) a simple normal message using color
# $@ = message
echon() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_NORMAL $COLOR_WHITE "$@"
  fi
}
# Echo (with newline) a debug message using color
# $@ = message
echodebug() {
  if [ -n "$1" ]; then
    echocolornl $COLOR_NORMAL $COLOR_YELLOW "$@"
  fi
}
# Append a message to log file /var/log/livedbg
# $@ = message
log() {
   echo "$@" 2>/dev/null >> /var/log/livedbg
}
# Same as doing echoinfo + log
# $@ = message
infolog() {
  if [ -n "$1" ]; then
    echoinfo "* $@"
    log "LIVE: $@"
  fi
}
# Same as doing echowarn + log
# $@ = message
warnlog() {
  if [ -n "$1" ]; then
    echowarn "* $@" >&2
    log "LIVE: $@"
  fi
}
# Same as doing echodebug + log
# $@ = message
debuglog() {
  if [ -n "$SALT_DEBUG" -a -n "$1" ]; then
    echodebug "$@" >&2
    log "DEBUG: $@"
  fi
}
# Run an interactive shell if in debug, else do nothing
debugshell() {
  if [ -n "$SALT_DEBUG" ]; then
    echo
    echoinfo '  +-----------------------------+'
    echoinfo '  |       Debugging shell       |'
    echoinfo '  |   Hit Ctrl+D to continue    |'
    echoinfo '  +-----------------------------+'
    echo
    hush
    echo
  fi
}
# Echo an error, try to run a shell, and the try to reboot
# $@ = optional message
fumble() {
  echo
  echoerror '  +-----------------------------+'
  echoerror '  |         Fatal Error         |'
  echoerror '  +-----------------------------+'
  echo
  [ -n "$1" ] && echoerror "$@"
  echoerror "Something went wrong and we can't continue. This should never happen."
  echoerror 'Please reboot your computer with Ctrl+Alt+Delete'
  echo
  hush || sh
  exec reboot -f
}

# Try to load a module. Check if the module is builtin or not.
# If it's builtin do nothing, else modprobe it.
# $1 = module name
# $2+ = optional options to pass to the module
modprobe_check() {
  MODULE=$1
  shift
  debuglog "Loading $MODULE module"
  OPTIONS="$*"
  MODULE2=$(echo $MODULE | tr '-' '_')
  grep "/$MODULE.ko\$" /lib/modules/$(uname -r)/modules.builtin >/dev/null 2>&1 || grep "/$MODULE2.ko\$" /lib/modules/$(uname -r)/modules.builtin >/dev/null 2>&1
  if [ $? -eq 0 ]; then
    debuglog "Module $MODULE is builtin"
  else
    modprobe $MODULE $OPTIONS
  fi
}

# Load essential modules, mainly filesystem modules.
load_modules() {
  modprobe_check loop
  modprobe_check isofs # for CD-ROM
  modprobe_check squashfs # for compressed readonly modules
  modprobe_check aufs brs=1 # for union fs
  modprobe_check ext2
  modprobe_check ext3
  modprobe_check ext4
  modprobe_check reiserfs
  modprobe_check xfs
  modprobe_check vfat # for fat16/fat32
  modprobe_check fuse # for ntfs-3g
}

# Initialize and populate /dev directory
init_dev() {
  mdev -s
}

# Load USB modules
load_usb_modules() {
  lspciusb=$(lspci -v | grep -i prog-if)
  found=
  if [ -n "$(echo $lspciusb | grep -i ehci)" ]; then
    modprobe_check ehci-hcd
    found=y
  fi
  if [ -n "$(echo $lspciusb | grep -i ohci)" ]; then
    modprobe_check ohci-hcd
    found=y
  fi
  if [ -n "$(echo $lspciusb | grep -i uhci)" ]; then
    modprobe_check uhci-hcd
    found=y
  fi
  if [ -n "$found" ]; then
    modprobe_check usb-storage
  fi
}

# Load PCMCIA modules
load_pcmcia_modules() {
  modprobe_check pcmcia_core # could be already loaded by ohci-hcd
  modprobe_check pcmcia # could be already loaded by ohci-hcd
  modprobe_check pcmcia_rsrc
  modprobe_check yenta_socket
}

# Show /dev/xxx devices, with optical devices first, and last USB connected devices first too.
# use a cache file (/devices) to improve performance.
find_mountable_devices() {
  if [ -e /devices ]; then
    cut -d: -f1 /devices
  else
    blkid|grep -v '^/dev/ram'|cut -d: -f1|sort -r|file -s -f -|tee /devices|cut -d: -f1
  fi
}

# Find the filesystem type as expected by "mount -t" of the specified device.
# $1 = device in the form /dev/xxx
find_fs_type() {
  [ ! -e /devices ] && find_mountable_devices >/dev/null
  LINE=$(grep "^$1:" /devices|cut -d: -f2-)
  if echo "$LINE"|grep -i 'ext4 filesystem data'>/dev/null; then
    echo 'ext4'
  elif echo "$LINE"|grep -i 'ext3 filesystem data'>/dev/null; then
    echo 'ext3'
  elif echo "$LINE"|grep -i 'ext2 filesystem data'>/dev/null; then
    echo 'ext2'
  elif echo "$LINE"|grep -i 'XFS filesystem data'>/dev/null; then
    echo 'xfs'
  elif echo "$LINE"|grep -i 'ReiserFS'>/dev/null; then
    echo 'reiserfs'
  elif echo "$LINE"|grep -i 'FAT'>/dev/null; then
    echo 'vfat'
  elif echo "$LINE"|grep -i 'NTFS'>/dev/null; then
    echo 'ntfs-3g'
  else
    warnlog "$1:$LINE: not supported filesystem"
    echo ''
  fi
}

# Find the options of the specified filesystem type.
# $1 = filesystem type
find_fs_options() {
  if [ "$1" = "ext4" -o "$1" = "ext3" -o "$1" = "ext2" ]; then
    echo 'noatime,defaults'
  elif [ "$1" = "xfs" ]; then
    echo 'noatime,defaults'
  elif [ "$1" = "reiserfs" ]; then
    echo 'noatime,defaults'
  elif [ "$1" = "vfat" ]; then
    echo 'noatime,defaults'
  elif [ "$1" = "ntfs-3g" ]; then
    echo 'umask=0000'
  else
    echo ''
  fi
}

# Mount the specified device and output the mount point.
# $1 = device in the form /dev/xxx
mount_device() {
  echo "$1"|grep '^/dev/' >/dev/null
  if [ $? -eq 0 ]; then
    DEV=$(echo "$1"|sed 's:/dev/::')
    TYPE=$(find_fs_type /dev/$DEV)
    OPTIONS=$(find_fs_options $TYPE)
    mkdir -p /mnt/$DEV
    debuglog "Mounting /dev/$DEV on /mnt/$DEV with type $TYPE and options: $OPTIONS"
    mount /dev/$DEV -t "$TYPE" -o "$OPTIONS" /mnt/$DEV >/dev/null 2>&1 && echo "/mnt/$DEV" || rmdir /mnt/$DEV
  fi
}

# Umount the specified device.
# $1 = device in the form /dev/xxx
umount_device() {
  echo "$1"|grep '^/dev/' >/dev/null
  if [ $? -eq 0 ]; then
    DEV=$(echo "$1"|sed 's:/dev/::')
    if mountpoint -q /mnt/$DEV; then
      debuglog "Umounting /mnt/$DEV"
      umount /mnt/$DEV && rmdir /mnt/$DEV
    else
      debuglog "/mnt/$DEV is already umounted"
    fi
  fi
}

# Find the device and mount point where the distro resides.
# Will output in the format '/dev/xxx:/mnt/xxx' if found.
find_distro_device() {
  for d in $(find_mountable_devices); do
    M=$(mount_device $d)
    if [ -n "$M" ]; then
      if [ -e $M/$IDENT_FILE ]; then
        C="$(cat $M/$IDENT_FILE)"
        if [ "$C" = "$IDENT_CONTENT" ]; then
          echo "$d:$M"|tee /distro_infos
          break
        fi
      fi
      debuglog "'/$IDENT_FILE:$IDENT_CONTENT' not found in $d"
      umount_device $d
    fi
  done
}

# Install hookers for cleanup.
# $1 = mount point of the distro
install_hookers() {
  M="$1"
  for b in halt poweroff reboot; do
    for d in sbin usr/sbin; do
      if [ -x $M/$d/$b ]; then
        file $M/$d/$b|grep executable >/dev/null
        if [ $? -eq 0 ]; then
          debuglog "Installing hook for $b in /$d"
          mv $M/$d/$b $M/$d/$b.orig
          (cd $M/$d; ln -s /mnt/salt/cleanup $b)
        fi
      fi
    done
  done
}

# Uninstall hookers for cleanup.
# $1 = mount point of the distro
uninstall_hookers() {
  M="$1"
  for b in halt poweroff reboot; do
    for d in sbin usr/sbin; do
      if [ -x $M/$d/$b.orig ]; then
        debuglog "Uninstalling hook for $b in /$d"
        mv $M/$d/$b.orig $M/$d/$b
      fi
    done
  done
}

# Change root for another process that will replace current process.
# The current directory should be positionned as the new root.
# $1 = new root
# $2 = directory in the new root for referencing the old root
# $3+ = command line to run. $1 must be a valid executable in the new root.
change_root_to() {
  NEW_ROOT="$1"
  OLD_ROOT="$2"
  shift
  shift
  debuglog "change_root_to: newroot=$NEW_ROOT oldroot=$OLD_ROOT args=$@"
  cd "$NEW_ROOT"
  mkdir -p "$OLD_ROOT"
  debuglog "remounting $NEW_ROOT readonly"
  mount -o remount,ro .
  pivot_root . "$OLD_ROOT"
  exec chroot . "$@" </dev/console >/dev/console 2>&1
  echoerror "Chroot to $PWD failed"
}
# chroot in the distro
# $@ = command line to run. $1 must be a valid executable in the new root.
change_root_to_distro() {
  if [ -f /distro_infos ]; then
    NEW_ROOT=$(cut -d: -f2 /distro_infos)
    change_root_to "$NEW_ROOT" mnt/salt "$@"
  else
    echoerror '/distro_infos file cannot be found'
  fi
}
# chroot back in the initrd
# $@ = command line to run. $1 must be a valid executable in the new root.
change_root_to_initrd() {
  if [ -f /mnt/salt/distro_infos ]; then
    OLD_ROOT=$(cut -d: -f2 /mnt/salt/distro_infos|sed 's:^/::')
    change_root_to /mnt/salt $OLD_ROOT "$@"
  else
    echoerror '/mnt/salt directory cannot be found'
  fi
}
